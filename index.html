<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UPSIDE DOWN: FINAL BATTLE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        
        /* Full Screen Overlay */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, #400, #000);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 9999; color: #f00; text-align: center;
        }

        #start-btn {
            padding: 25px 60px; font-size: 28px; background: #800; color: #fff;
            border: 4px solid #f00; cursor: pointer; box-shadow: 0 0 50px #f00;
            font-weight: bold; text-transform: uppercase; margin-top: 30px; display: none;
        }

        #hud {
            position: fixed; top: 20px; left: 20px; color: #f00; z-index: 100;
            background: rgba(0,0,0,0.85); padding: 20px; border: 2px solid #f00;
            border-radius: 10px; display: none; pointer-events: none;
        }

        #cam-container {
            position: fixed; bottom: 20px; right: 20px; width: 250px; height: 180px;
            border: 3px solid #f00; z-index: 100; transform: scaleX(-1);
            background: #000; border-radius: 15px; overflow: hidden; box-shadow: 0 0 20px #f00;
        }

        #blood-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(150, 0, 0, 0.4); pointer-events: none;
            display: none; z-index: 50;
        }

        video { width: 100%; height: 100%; object-fit: cover; }
        canvas { display: block; }
    </style>
</head>
<body>

    <div id="loader">
        <h1 style="font-size: 60px; letter-spacing: 15px; margin-bottom: 10px;">VECNA'S WRATH</h1>
        <p id="load-msg">CONNECTING TO THE UPSIDE DOWN...</p>
        <div style="width: 300px; height: 5px; background: #200; margin: 20px;"><div id="progress" style="width: 0%; height: 100%; background: #f00;"></div></div>
        <button id="start-btn">ENTER REALM</button>
    </div>

    <div id="hud">
        <h2 id="phase-txt">PHASE 1: 5 DEMOGORGONS</h2>
        <p>KILLS: <span id="kill-val">0/5</span></p>
        <p style="color: #666; font-size: 12px; margin-top: 10px;">üñêÔ∏è GRAB | üëä CRUNCH | ‚úåÔ∏è THROW</p>
    </div>

    <div id="blood-overlay"></div>

    <div id="cam-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // --- SOUND LOGIC ---
        const sfx = {
            bg: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-horror-low-drone-hum-2495.mp3'),
            snap: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-crunchy-bone-break-422.mp3'),
            blast: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-thunder-rumble-2321.mp3'),
            scream: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-creature-cry-of-pain-2083.mp3')
        };

        let scene, camera, renderer, hands, video, captured = null, enemies = [], killCount = 0;
        let particles = [];

        // --- INITIALIZATION ---
        window.onload = () => {
            let p = 0;
            const bar = document.getElementById('progress');
            const interval = setInterval(() => {
                p += Math.random() * 15;
                if(p >= 100) {
                    p = 100; clearInterval(interval);
                    document.getElementById('load-msg').innerText = "LINK READY";
                    document.getElementById('start-btn').style.display = 'block';
                }
                bar.style.width = p + "%";
            }, 100);
        };

        async function initGame() {
            video = document.getElementById('webcam');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                
                setupThreeJS();
                setupHands();
                
                const mpCam = new Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 640, height: 480
                });
                mpCam.start();

                document.getElementById('loader').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                
                // Audio Unlock
                sfx.bg.loop = true; sfx.bg.volume = 0.5; sfx.bg.play();
                
                animate();
            } catch (e) {
                alert("CAMERA FAILED: Please allow camera access and use HTTPS.");
            }
        }

        function setupThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050000);
            scene.fog = new THREE.Fog(0x050000, 50, 300);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.set(0, 45, 140);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lightning Lighting
            const amb = new THREE.AmbientLight(0xff0000, 0.2);
            scene.add(amb);
            
            // Ground with Heavy Veins
            const groundGeo = new THREE.PlaneGeometry(1000, 1000);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x080000 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI/2;
            scene.add(ground);

            for(let i=0; i<100; i++) {
                const pts = [];
                let startX = (Math.random()-0.5)*400;
                let startZ = (Math.random()-0.5)*400;
                for(let j=0; j<6; j++) pts.push(new THREE.Vector3(startX + j*10, Math.random()*3, startZ + Math.sin(j)*20));
                const curve = new THREE.CatmullRomCurve3(pts);
                const tube = new THREE.Mesh(new THREE.TubeGeometry(curve, 20, 0.4, 8, false), new THREE.MeshBasicMaterial({color: 0x330000}));
                scene.add(tube);
            }

            spawnInitialEnemies();
        }

        function spawnInitialEnemies() {
            for(let i=0; i<5; i++) {
                const en = createMonster("DEMO");
                en.position.set((Math.random()-0.5)*180, 0, (Math.random()-0.5)*100);
                enemies.push(en);
                scene.add(en);
            }
        }

        function createMonster(type) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x221111, emissive: 0xff0000, emissiveIntensity: 0.1 });
            
            // Detailed Torso
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(4, 12, 4, 8), mat);
            body.position.y = 12;
            group.add(body);

            // Head (Petals for Demo)
            const head = new THREE.Mesh(new THREE.SphereGeometry(4, 12, 12), mat);
            head.position.y = 24;
            group.add(head);

            // Limbs
            const limbGeo = new THREE.CylinderGeometry(1, 0.5, 15);
            for(let i=0; i<4; i++){
                const limb = new THREE.Mesh(limbGeo, mat);
                limb.position.y = 10;
                limb.position.x = i%2==0 ? 5 : -5;
                limb.position.z = i<2 ? 3 : -3;
                group.add(limb);
            }

            group.userData = { hp: 100, type: type };
            return group;
        }

        function setupHands() {
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75 });
            hands.onResults(results => {
                if(!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    if(captured) { captured.scale.set(1,1,1); captured = null; }
                    return;
                }
                const lm = results.multiHandLandmarks[0];
                const hX = (lm[8].x - 0.5) * -240;
                const hY = (lm[8].y - 0.5) * -160 + 50;

                const isOpen = lm[8].y < lm[6].y && lm[12].y < lm[10].y;
                const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y;
                const isPeace = isOpen && lm[16].y > lm[14].y;

                if(!captured && isOpen) {
                    enemies.forEach(en => {
                        const d = Math.sqrt(Math.pow(en.position.x - hX, 2) + Math.pow(en.position.y - hY, 2));
                        if(d < 40) { captured = en; sfx.scream.play(); }
                    });
                }

                if(captured) {
                    if(isFist) {
                        // THE BONE CRUNCH
                        sfx.snap.currentTime = 0; sfx.snap.play();
                        captured.scale.y *= 0.88; // Squish
                        captured.scale.x *= 1.05; // Spread
                        captured.userData.hp -= 5;
                        triggerBlood();
                        if(captured.userData.hp <= 0) {
                            killTarget(captured);
                        }
                    } else if(isPeace) {
                        captured.scale.set(1,1,1);
                        captured = null;
                    } else {
                        // TELEKINETIC GRAB & STRETCH
                        captured.position.lerp(new THREE.Vector3(hX, hY, 0), 0.2);
                        captured.scale.set(1.5, 2.0, 0.8); // Vecna-style stretching
                        captured.rotation.x += 0.1;
                    }
                }
            });
        }

        function triggerBlood() {
            const b = document.getElementById('blood-overlay');
            b.style.display = 'block';
            setTimeout(() => b.style.display = 'none', 150);
        }

        function killTarget(obj) {
            sfx.blast.play();
            scene.remove(obj);
            enemies = enemies.filter(e => e !== obj);
            captured = null;
            killCount++;
            document.getElementById('kill-val').innerText = `${killCount}/5`;
            
            if(killCount === 5) {
                spawnVecna();
            }
        }

        function spawnVecna() {
            document.getElementById('phase-txt').innerText = "FINAL PHASE: VECNA";
            const vecna = createMonster("VECNA");
            vecna.scale.set(3, 3, 3);
            vecna.position.set(0, 0, -50);
            vecna.userData.hp = 500;
            enemies.push(vecna);
            scene.add(vecna);
            sfx.blast.play();
        }

        function animate() {
            requestAnimationFrame(animate);
            // Lightning Logic
            if(Math.random() > 0.985) {
                scene.background = new THREE.Color(0x330000);
                setTimeout(() => scene.background = new THREE.Color(0x050000), 40);
            }
            // Idle movement
            enemies.forEach(en => {
                if(en !== captured) {
                    en.position.z += Math.sin(Date.now()*0.002)*0.3;
                    en.rotation.y += 0.01;
                }
            });
            renderer.render(scene, camera);
        }

        document.getElementById('start-btn').onclick = initGame;
    </script>
</body>
</html>
